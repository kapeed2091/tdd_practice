USE CASES:
    - User can create an account in wallet.
    - User can check his balance.
    - User can add money to his account in wallet.
    - User can see transactions statement.
    - User can transfer money from his wallet to another user wallet.

Architecture/Design: Should we fix the architechture? - task division/teams - to divide different apps?
    - API Layer, Functionality Layer.
    - Apps: Users (Third Party), Wallet.
    - Models:
        Wallet:
            - Transactions.
            - Account.

#######################################

TDD TODO List (Functionality Layer):
    - Create Account
        - account_id, customer_id lengths
    - Get Balance
        - When user has non-zero balance
    - Add balance
        - negative balance add?
        -
    - Transfer Money
    - Get Statement

    Done:
       - Create Account
            - 2 users should get different account numbers
            - account already exists
            - each customer has only 1 account :Refactoring
            - no joint accounts
       - Get Balance
            - 0 balance for new user
            - if customer doesn't exist
       - Add Balance
           - add 10 balance
           -

#######################################
// Notes

Steps:
    - Create app
    - Create Tests Folder and test file
    - Write test: Create Account
    - Run test case - gives compile errors
    - Fix compile errors - create Account Model
    - Gives Red State
    - Fake implementation
    - Get Green State

    - Triangulation
        - Add another test case
        - Got to Red state
    - Refactoring code
    - Get Green state

    - Pickup new from scratch pad - []
    - Refactor "function name" - do it in testcases as well
    - Run tests - Green
    - Add new test case
    - Red state
    - obvious implementation


Developers should also think about business usecases and should ask business team if there are any suggestions, doubts, improvements

Architecture checklist

Checklist for business usecases: should evolve this over a period of time
    - unique,
    - field lengths,
    - etc.


Have regular archtechtural reviews, for design refinements - 2 hrs in each sprint?

Test cases shouldn't depend on implementation


// Have to decide

1. Design vs Development
2. Checking DB state checks in TDD?
3. Test case - for use_case OR function. ex: Create account - should it just check funtion. should it also check db state etc. to see if the account is created
4. Do we get comprehensive test cases with TDD? If not, how do we get confidence
5. Should we handle concurrency testcases in TDD?
6.

// Doubt
1. DB objects vs Data structures - how do we maintain?
2. How to write testcase for joint accounts [unique constraints]?
        - Assign account_id to customer
3. Are DB level constraints required? If DB level constraints required, then how do we ensure them?
4. Writing testable code - Mocking UUID vs Refactoring Code
5. If customer doesn't exist - wrote test case - which already has implementation: shoud we do this?
6.
